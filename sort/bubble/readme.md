# 冒泡排序

代码演示 排序方式 从小到大

## 直接遍历

遍历元素集合，如果相邻两元素顺序不对则交换，重复操作直到集合有序。比如整型数组



## 优化一：检测是否已提前有序

可看到第二趟结束数组已排序完毕，但嵌套的 `for` 循环仍在遍历第三趟、第四趟。此时可以设标志 `flag`：某趟遍历只要发生了交换则`flag = true`，从未发生交换则为 `false` 说明提前有序。


## 优化二：缩短扫描距离

可记录每趟最后发生交换的位置，此位置之后均已有序，下一趟只需遍历到此位置即可。这种实现直接暴力遍历，与前两种不太一样。


## 优化三：双向冒泡排序（鸡尾酒排序）

每趟向后遍历排为从低到高，再向前遍历从高到低。


## 使用场景

冒泡排序的关键是双重嵌套的循环，时间复杂度是很高的 **O(N^2)**，大多数情况下效率很低，适用于大量元素已有序的集合、少量无序元素的集合。

冒泡排序的空间复杂度为 **O(1)**，同时因为进行两两比较，相同元素间的次序不变，稳定性高。